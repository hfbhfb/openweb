(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{1018:function(t,e,a){"use strict";a.r(e);var s=a(28),i=Object(s.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("ul",[s("li",[s("p",[t._v("go垃圾回收实现  数字:25%cpu消耗作为目标")])]),t._v(" "),s("li",[s("img",{staticStyle:{zoom:"50%"},attrs:{src:a(662),alt:"image-20210401170731774"}})]),t._v(" "),s("li",[s("p",[t._v("结束时间点")])]),t._v(" "),s("li",[s("img",{staticStyle:{zoom:"50%"},attrs:{src:a(663),alt:"image-20210401175728513"}})]),t._v(" "),s("li",[s("p",[t._v("标记工作")])]),t._v(" "),s("li",[s("p",[t._v("步骤1: 扫描"),s("code",[t._v("bss段")]),t._v(","),s("code",[t._v("数据段")]),t._v(","),s("code"),t._v("协程栈` 上 root节点开始")])]),t._v(" "),s("li",[s("p",[t._v("步骤2:如何确定指针是  GC  感兴趣的?  "),s("code",[t._v("元数据")]),t._v(" "),s("code",[t._v("扫描协程栈-局部变量,参数,返回值,stackmask")]),t._v(" "),s("code",[t._v("编译到可执行文件有gcbssmask,gcdatamask")])])]),t._v(" "),s("li",[s("img",{staticStyle:{zoom:"50%"},attrs:{src:a(664),alt:"image-20210401235027810"}})]),t._v(" "),s("li",[s("p",[t._v("步骤3: 判断指针是否指向 "),s("code",[t._v("堆内存")]),t._v(" ? 如果是则加入到GC工作队列中")])]),t._v(" "),s("li",[s("p",[t._v("mheap 结构如下   "),s("code",[t._v("管理着虚拟地址空间中一大段连续的内存")]),t._v(" "),s("code",[t._v("8k为一个页,多个页组成一个span")]),t._v(" "),s("code",[t._v("多个span组成arena")])])]),t._v(" "),s("li",[s("p",[s("code",[t._v("每个span只存储一种大小的元素")]),t._v(" "),s("code",[t._v("mspan")]),t._v(" "),s("code",[t._v("elemsize")]),t._v(" "),s("code",[t._v("spanclass")])])]),t._v(" "),s("li",[s("img",{staticStyle:{zoom:"50%"},attrs:{src:a(665),alt:"image-20210402002539606"}})]),t._v(" "),s("li",[s("p",[t._v("_type类型元数据  "),s("code",[t._v("ptrdata标识是否有指针")]),t._v(" "),s("code",[t._v("scan")]),t._v(" "),s("code",[t._v("no-scan")])])]),t._v(" "),s("li",[s("img",{staticStyle:{zoom:"50%"},attrs:{src:a(666),alt:"image-20210402002854203"}})]),t._v(" "),s("li",[s("p",[t._v("同步开销问题  => "),s("code",[t._v("central")]),t._v(" "),s("code",[t._v("local - 以P为单位")])])]),t._v(" "),s("li",[s("img",{staticStyle:{zoom:"50%"},attrs:{src:a(667),alt:"image-20210402003916693"}})]),t._v(" "),s("li",[s("p",[s("code",[t._v("nonempty span")]),t._v(" "),s("code",[t._v("empty span")]),t._v("  进行分别管理")])]),t._v(" "),s("li",[s("p",[t._v("以P为单位管理内存申请 ,  区别  central 进行申请内存")])]),t._v(" "),s("li",[s("img",{staticStyle:{zoom:"50%"},attrs:{src:a(668),alt:"image-20210402004226388"}})]),t._v(" "),s("li",[s("p",[t._v("有哪些"),s("code",[t._v("GC")]),t._v("用得到的"),s("code",[t._v("元数据信息")])])]),t._v(" "),s("li",[s("p",[t._v("1:1  arena=>HeapArena  "),s("code",[t._v("一个字节标记连续4个指针大小的内存")])])]),t._v(" "),s("li",[s("p",[s("code",[t._v("bitmap")]),t._v(" "),s("code",[t._v("spans")])])]),t._v(" "),s("li",[s("img",{staticStyle:{zoom:"50%"},attrs:{src:a(669),alt:"image-20210402013522499"}})]),t._v(" "),s("li",[s("p",[t._v("mspan 结构体有哪些GC关心的数据  "),s("code",[t._v("判断对象是否存活")]),t._v(" "),s("code",[t._v("通过位图进行一对一标记")])])]),t._v(" "),s("li",[s("img",{staticStyle:{zoom:"50%"},attrs:{src:a(670),alt:"image-20210402013838001"}})]),t._v(" "),s("li",[s("p",[t._v("混合写屏障")])]),t._v(" "),s("li",[s("img",{staticStyle:{zoom:"50%"},attrs:{src:a(671),alt:"image-20210402042152297"}})])]),t._v(" "),s("h2",{attrs:{id:"linux可执行进程对应的虚拟地址空间的五个段"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#linux可执行进程对应的虚拟地址空间的五个段"}},[t._v("#")]),t._v(" Linux可执行进程对应的虚拟地址空间的五个段")]),t._v(" "),s("ul",[s("li",[t._v("BSS段：BSS段（bss segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。BSS是英文Block Started by Symbol的简称。BSS段属于静态内存分配。")]),t._v(" "),s("li",[t._v("数据段：数据段（data segment）通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。")]),t._v(" "),s("li",[t._v("代码段：代码段（code segment/text segment）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。")]),t._v(" "),s("li",[t._v("堆（heap）：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）若程序员不释放，则会有内存泄漏，系统会不稳定")]),t._v(" "),s("li",[t._v("栈(stack)：栈又称堆栈， 是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变 量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中")])]),t._v(" "),s("p",[s("a",{attrs:{href:"https://www.bilibili.com/video/BV1Ui4y1F7n3/?spm_id_from=autoNext",target:"_blank",rel:"noopener noreferrer"}},[t._v("素材来源视频"),s("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=i.exports},662:function(t,e,a){t.exports=a.p+"assets/img/image-20210401170731774.cb50ff56.png"},663:function(t,e,a){t.exports=a.p+"assets/img/image-20210401175728513.a289b137.png"},664:function(t,e,a){t.exports=a.p+"assets/img/image-20210401235027810.c5b3c059.png"},665:function(t,e,a){t.exports=a.p+"assets/img/image-20210402002539606.65450d52.png"},666:function(t,e,a){t.exports=a.p+"assets/img/image-20210402002854203.09d942ce.png"},667:function(t,e,a){t.exports=a.p+"assets/img/image-20210402003916693.ed21b711.png"},668:function(t,e,a){t.exports=a.p+"assets/img/image-20210402004226388.e7a66fc1.png"},669:function(t,e,a){t.exports=a.p+"assets/img/image-20210402013522499.eb40aacf.png"},670:function(t,e,a){t.exports=a.p+"assets/img/image-20210402013838001.018a2883.png"},671:function(t,e,a){t.exports=a.p+"assets/img/image-20210402042152297.6969e8c3.png"}}]);